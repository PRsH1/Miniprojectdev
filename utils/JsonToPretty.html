<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON & XML Formatter</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/lint/lint.min.css">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f7f6;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 98%; 
            max-width: 1600px; 
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            box-sizing: border-box;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-top: 0;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 24px;
            border: none;
            border-radius: 6px;
            background-color: #0070f3;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #005bb5; }
        button.clear-btn { background-color: #e0e0e0; color: #333; }
        button.clear-btn:hover { background-color: #c8c8c8; }
        
        .error-msg {
            color: #d32f2f; font-size: 15px; font-weight: bold; text-align: center;
            min-height: 24px; margin-bottom: 15px; white-space: pre-wrap;
        }
        
        .editor-container {
            display: flex; gap: 20px; width: 100%;
        }
        .editor-pane {
            flex: 1; display: flex; flex-direction: column; min-width: 0;
        }
        
        .pane-header {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;
        }
        .pane-header h3 { margin: 0; font-size: 16px; color: #555; display: flex; align-items: center; gap: 10px; }
        
        .copy-btn {
            padding: 4px 12px; font-size: 12px; border-radius: 4px; background-color: #4caf50; 
            color: white; border: none; cursor: pointer; display: none;
        }
        .copy-btn:hover { background-color: #45a049; }

        .tabs { display: flex; gap: 5px; }
        .tab-btn {
            padding: 5px 10px; font-size: 13px; cursor: pointer; border: none;
            background-color: #f0f0f0; color: #555; border-radius: 4px;
        }
        .tab-btn.active { background-color: #333; color: white; }

        /* 새로 교체된 입력창(CodeMirror) 스타일 */
        #editorWrapper {
            width: 100%; 
            height: 70vh; 
            min-height: 500px; 
            border: 1px solid #ccc;
            border-radius: 6px; 
            box-sizing: border-box; 
            overflow: hidden;
        }
        .CodeMirror {
            height: 100%;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            background-color: #fafafa;
        }
        .CodeMirror-focused { background-color: #fff; border-color: #0070f3; }

        /* 결과창 영역 */
        .output-wrapper {
            height: 70vh; 
            min-height: 500px; 
            border: 1px solid #ccc; border-radius: 6px; overflow: auto;
            background-color: #1d1f21; 
            position: relative;
        }
        #codeView pre { margin: 0; padding: 15px; background: transparent; }
        
        /* 트리 뷰 스타일 */
        #treeView {
            padding: 15px; font-family: 'Courier New', Courier, monospace; font-size: 14px;
            display: none; background-color: #ffffff; color: #333; min-height: 100%; box-sizing: border-box;
        }
        details { margin-left: 15px; }
        summary { cursor: pointer; outline: none; display: flex; align-items: center; padding: 2px 0; }
        summary:hover { background-color: #f5f5f5; }
        summary::marker { color: #888; }
        
        .tree-key { color: #d32f2f; font-weight: bold; }
        .tree-count { color: #888; font-size: 13px; margin-left: 5px; }
        .tree-value-string { color: #2e7d32; }
        .tree-value-number { color: #1565c0; }
        .tree-link { color: #2e7d32; text-decoration: underline; }
        ul.tree-list { margin: 0; padding-left: 15px; list-style-type: none; border-left: 1px dashed #ddd; }
        .tree-bracket { color: #555; }

        @media (max-width: 768px) {
            .editor-container { flex-direction: column; }
            #editorWrapper, .output-wrapper { height: 50vh; min-height: 350px; }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>JSON & XML Formatter</h1>
    
    <div class="controls">
        <button onclick="formatJSON()">Format JSON</button>
        <button onclick="formatXML()">Format XML</button>
        <button onclick="clearAll()" class="clear-btn">Clear</button>
    </div>

    <div class="error-msg" id="errorMessage"></div>

    <div class="editor-container">
        <div class="editor-pane">
            <div class="pane-header">
                <h3>Input (Auto Detect & Linting)</h3>
            </div>
            <div id="editorWrapper"></div>
        </div>

        <div class="editor-pane">
            <div class="pane-header">
                <h3>
                    Output 
                    <button id="copyBtn" class="copy-btn" onclick="copyOutput()">Copy</button>
                </h3>
                <div class="tabs">
                    <button id="btnCode" class="tab-btn active" onclick="switchTab('code')">Formatted</button>
                    <button id="btnTree" class="tab-btn" onclick="switchTab('tree')">Tree View</button>
                </div>
            </div>
            
            <div class="output-wrapper">
                <div id="codeView">
                    <pre><code id="outputCode" class="language-json">결과가 여기에 표시됩니다...</code></pre>
                </div>
                <div id="treeView"></div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jsonlint/1.6.0/jsonlint.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/lint/lint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/lint/json-lint.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>

<script>
    // ==========================================
    // CodeMirror 커스텀 XML Linter (빨간 밑줄 기능)
    // ==========================================
    CodeMirror.registerHelper("lint", "xml", function(text) {
        var found = [];
        if (!text.trim()) return found;
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(text, "application/xml");
            const parserError = xmlDoc.getElementsByTagName("parsererror");
            
            if (parserError.length > 0) {
                const errorText = parserError[0].textContent;
                let line = 1, ch = 0;
                
                // 브라우저마다 파싱 에러 메시지 포맷이 다르므로 정규식으로 라인 추출
                let lineMatch = errorText.match(/line\s+(\d+)/i) || errorText.match(/Line Number\s+(\d+)/i);
                let colMatch = errorText.match(/column\s+(\d+)/i) || errorText.match(/Column\s+(\d+)/i);
                
                if (lineMatch) line = parseInt(lineMatch[1], 10);
                if (colMatch) ch = parseInt(colMatch[1], 10);

                // CodeMirror에 에러 위치 전달
                found.push({
                    from: CodeMirror.Pos(line - 1, Math.max(0, ch - 2)),
                    to: CodeMirror.Pos(line - 1, ch + 2),
                    message: errorText.split('\n')[0] || "XML Parsing Error",
                    severity: "error"
                });
            }
        } catch (e) {
            console.error(e);
        }
        return found;
    });

    // ==========================================
    // CodeMirror 초기화
    // ==========================================
    const editor = CodeMirror(document.getElementById("editorWrapper"), {
        lineNumbers: true, // 줄 번호 표시
        mode: "application/json",
        lint: true, // 실시간 에러 밑줄 활성화
        gutters: ["CodeMirror-lint-markers"], // 에러 마크 영역 확보
        lineWrapping: true,
        placeholder: "여기에 원본 JSON 또는 XML 코드를 붙여넣으세요..."
    });

    // 입력 내용 변경 시 JSON/XML 자동 감지 및 모드 전환
    editor.on("change", function() {
        const val = editor.getValue().trim();
        let currentMode = editor.getOption("mode");
        
        if (val.startsWith("<") && currentMode !== "xml") {
            editor.setOption("mode", "xml"); // XML 문법 검사기로 자동 전환
        } else if ((val.startsWith("{") || val.startsWith("[")) && currentMode !== "application/json") {
            editor.setOption("mode", "application/json"); // JSON 문법 검사기로 자동 전환
        }
    });

    // ==========================================
    // 기존 UI 로직 연동
    // ==========================================
    const outputCode = document.getElementById('outputCode');
    const treeView = document.getElementById('treeView');
    const codeView = document.getElementById('codeView');
    const errorMessage = document.getElementById('errorMessage');
    const copyBtn = document.getElementById('copyBtn');
    let currentFormattedText = "";

    function showError(msg) { errorMessage.textContent = msg; } // 에러 메시지 표시
    function clearError() { errorMessage.textContent = ''; } // 에러 메시지 초기화

    function clearAll() {
        // 에디터와 결과창 초기화
        editor.setValue(''); // 에디터 초기화
        currentFormattedText = '';
        outputCode.textContent = '결과가 여기에 표시됩니다...';
        outputCode.className = 'language-json';
        treeView.innerHTML = '';
        copyBtn.style.display = 'none';
        Prism.highlightElement(outputCode);
        clearError();
    }

    function switchTab(tab) {
        // 탭 버튼 활성화 상태 업데이트 및 뷰 전환
        document.getElementById('btnCode').classList.remove('active');
        document.getElementById('btnTree').classList.remove('active');
        if (tab === 'code') {
            document.getElementById('btnCode').classList.add('active');
            codeView.style.display = 'block';
            treeView.style.display = 'none';
        } else {
            document.getElementById('btnTree').classList.add('active');
            codeView.style.display = 'none';
            treeView.style.display = 'block';
        }
    }

    function copyOutput() {
        // 현재 포맷된 텍스트를 클립보드에 복사
        if (!currentFormattedText) return;
        navigator.clipboard.writeText(currentFormattedText).then(() => {
            copyBtn.textContent = "Copied!";
            copyBtn.style.backgroundColor = "#2e7d32";
            setTimeout(() => {
                copyBtn.textContent = "Copy";
                copyBtn.style.backgroundColor = "#4caf50";
            }, 2000);
        }).catch(err => alert("복사에 실패했습니다."));
    }

    function formatJSON() {
        // JSON 포맷팅 및 트리 뷰 생성
        clearError();
        const rawValue = editor.getValue().trim(); // 에디터에서 값 가져오기
        if (!rawValue) return showError("입력창에 JSON 코드를 입력해 주세요.");

        try {
            const parsedObj = JSON.parse(rawValue);
            currentFormattedText = JSON.stringify(parsedObj, null, 4);
            outputCode.className = 'language-json';
            outputCode.textContent = currentFormattedText;
            Prism.highlightElement(outputCode);

            treeView.innerHTML = '';
            treeView.appendChild(buildJSONTree(parsedObj, "root", true));
            
            copyBtn.style.display = 'block';
            switchTab('code');
        } catch (e) {
            showError(`유효하지 않은 JSON 형식입니다.\n${e.message}`);
        }
    }

    function isUrl(string) {
        // 간단한 URL 검증 (https:// 또는 http://로 시작하는 경우)
        try { return Boolean(new URL(string)); }
        catch(e) { return false; }
    }

    function buildJSONTree(data, keyName = "", isRoot = false) {
        // 최상위 노드인 경우 keyName을 표시하지 않음
        const wrapper = document.createElement('div');
        const keySpan = keyName ? `<span class="tree-key">${keyName}</span> : ` : "";

        if (data !== null && typeof data === 'object') {
            // 객체 또는 배열인 경우 details/summary 구조로 트리 생성
            const isArray = Array.isArray(data);
            const count = isArray ? data.length : Object.keys(data).length;
            const details = document.createElement('details');
            details.open = true;
            
            const summary = document.createElement('summary');
            const countLabel = `<span class="tree-count">${isArray ? '[' + count + ']' : '{' + count + '}'}</span>`;
            summary.innerHTML = `${keySpan}<span class="tree-bracket">${isArray ? 'Array' : 'Object'}</span> ${countLabel}`;
            details.appendChild(summary);

            const ul = document.createElement('ul');
            ul.className = 'tree-list';
            for (const key in data) {
                const li = document.createElement('li');
                li.appendChild(buildJSONTree(data[key], isArray ? key : `"${key}"`));
                ul.appendChild(li);
            }
            details.appendChild(ul);
            wrapper.appendChild(details);
        } else {
            let valueStr = "";
            if (typeof data === 'string') {
                if(isUrl(data)) valueStr = `<a href="${data}" target="_blank" class="tree-link">"${data}"</a>`;
                else valueStr = `<span class="tree-value-string">"${data}"</span>`;
            } else if (typeof data === 'number' || typeof data === 'boolean') {
                valueStr = `<span class="tree-value-number">${data}</span>`;
            } else valueStr = `<span class="tree-value-number">null</span>`;
            wrapper.innerHTML = `<div style="padding: 2px 0 2px 15px;">${keySpan}${valueStr}</div>`;
        }
        return wrapper;
    }

    function formatXML() {
        // XML 포맷팅 및 트리 뷰 생성
        clearError();
        let xml = editor.getValue().trim(); // 에디터에서 값 가져오기
        if (!xml) return showError("입력창에 XML 코드를 입력해 주세요.");

        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xml, "application/xml");
            const parserError = xmlDoc.getElementsByTagName("parsererror");
            if (parserError.length > 0) throw new Error(parserError[0].textContent);

            let formatted = '';
            let pad = 0;
            const reg = /(>)(<)(\/*)/g;
            xml = xml.replace(reg, '$1\r\n$2$3');
            
            xml.split('\r\n').forEach(function(node) {
                // 들여쓰기 규칙:
                let indent = 0;
                if (node.match( /.+<\/\w[^>]*>$/ )) indent = 0; 
                else if (node.match( /^<\/\w/ )) { if (pad !== 0) pad -= 1; } 
                else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) indent = 1; 
                else indent = 0;

                formatted += '    '.repeat(pad) + node + '\r\n';
                pad += indent;
            });

            currentFormattedText = formatted.trim();
            outputCode.className = 'language-xml';
            outputCode.textContent = currentFormattedText;
            Prism.highlightElement(outputCode);

            treeView.innerHTML = '';
            Array.from(xmlDoc.childNodes).forEach(node => {
                const treeNode = buildXMLTree(node);
                if (treeNode) treeView.appendChild(treeNode);
            });

            copyBtn.style.display = 'block';
            switchTab('code');
        } catch (e) {
            showError(`유효하지 않은 XML 형식입니다.\n${e.message.split('\n')[0]}`);
        }
    }

    function buildXMLTree(node) {
        // 텍스트 노드인 경우
        if (node.nodeType === Node.TEXT_NODE) {
           
            const text = node.textContent.trim();
            if (!text) return null;
            const wrapper = document.createElement('div');
            wrapper.innerHTML = `<div style="padding: 2px 0 2px 15px;"><span class="tree-value-string">"${text}"</span></div>`;
            return wrapper;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const wrapper = document.createElement('div');
            const elementChildren = Array.from(node.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE);
            const hasElementChildren = elementChildren.length > 0;
            const textContent = Array.from(node.childNodes).filter(n => n.nodeType === Node.TEXT_NODE).map(n => n.textContent.trim()).join('');

            if (hasElementChildren) {
                // 자식 요소가 있는 경우 details/summary 구조로 트리 생성
                const details = document.createElement('details');
                details.open = true;
                const summary = document.createElement('summary');
                const countLabel = `<span class="tree-count">{${elementChildren.length}}</span>`;
                summary.innerHTML = `<span class="tree-key">&lt;${node.nodeName}&gt;</span> ${countLabel}`;
                details.appendChild(summary);

                const ul = document.createElement('ul');
                ul.className = 'tree-list';
                node.childNodes.forEach(child => {
                    const childNode = buildXMLTree(child); // 재귀적으로 자식 노드 처리
                    if (childNode) {
                        // 자식 노드가 유효한 경우에만 리스트에 추가
                        const li = document.createElement('li');
                        li.appendChild(childNode);
                        ul.appendChild(li);
                    }
                });
                details.appendChild(ul);
                wrapper.appendChild(details);
            } else {
                // 자식 요소가 없고 텍스트만 있는 경우 한 줄로 표시
                wrapper.innerHTML = `<div style="padding: 2px 0 2px 15px;"><span class="tree-key">&lt;${node.nodeName}&gt;</span> <span class="tree-value-string">${textContent}</span> <span class="tree-key">&lt;/${node.nodeName}&gt;</span></div>`;
            }
            return wrapper;
        }
        return null;
    }
</script>

</body>
</html>